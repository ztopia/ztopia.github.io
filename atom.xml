<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ztopia&#39;blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/ztopia/ztopia.github.io.git/"/>
  <updated>2017-11-26T01:52:04.680Z</updated>
  <id>https://github.com/ztopia/ztopia.github.io.git/</id>
  
  <author>
    <name>ztopia</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test</title>
    <link href="https://github.com/ztopia/ztopia.github.io.git/2017/11/26/test/"/>
    <id>https://github.com/ztopia/ztopia.github.io.git/2017/11/26/test/</id>
    <published>2017-11-26T01:52:04.000Z</published>
    <updated>2017-11-26T01:52:04.680Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>装饰器</title>
    <link href="https://github.com/ztopia/ztopia.github.io.git/2017/06/22/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://github.com/ztopia/ztopia.github.io.git/2017/06/22/装饰器/</id>
    <published>2017-06-22T13:06:03.000Z</published>
    <updated>2017-11-26T01:29:42.413Z</updated>
    
    <content type="html"><![CDATA[<p>#装饰器<br>装饰器本质上就是一个函数<br><a id="more"></a></p><p>##类装饰器</p><p>@decoration</p><p>class Person {<br>        static arr:any[]=[1,2,3]<br>}</p><p>Person类就是需要装饰的原型，@decoration就是调用哪个函数来装饰这个类</p><p>function decoration(target:any):void{<br>       let arrNew=[4,5,6];<br>       if(target.arr){<br>                target.arr.push(…arrNew)<br>       }<br>}</p><p>要实现装饰功能，需要将之前的类传递给装饰函数，这个函数也是用来服用的函数<br>target用来接收来自类的属性和方法</p><p>##方法装饰器</p><p>class Person {<br>    @readonly<br>    run(): void {<br>        console.log(‘跑’)<br>    }<br>}</p><p>//这里的run()是一个实例对象，所以，装饰器接收到的原型</p><p>function readonly(…arg: any[]) {<br>    arg[2].writable = false;<br>}</p><p>// 自动收到的参数1, 实例方法为原型, 静态方法为类<br>// 自动收到的参数2, 为方法的名称<br>// 自动收到的参数3, 为方法的描述对象<br>这里将第三个参数中的writable属性做了更改。</p><p>##装饰器工厂</p><p>// 装饰器工厂内部返回一个函数, 内部的函数就是我们之前写的装饰器函数</p><p>##属性装饰器</p><p>class Person {<br>    @propZhuangshiqi<br>    name: string = ‘匿名’;</p><pre><code>@propZhuangshiqistatic age: number = 0;</code></pre><p>}</p><p>属性分为实例属性和静态属性</p><p>function propZhuangshiqi(…arg: any[]): void {<br>    let classOrPrototype = arg[0];  // 类或原型<br>    let propName = arg[1];          // 属性名称</p><pre><code>// 根据属性名称添加对应的set方法classOrPrototype[&apos;set&apos; + propName] = function(val: any): void {    this[propName] = val;}// 根据属性名称添加对应的get方法classOrPrototype[&apos;get&apos; + propName] = function(): any {    return this[propName];}</code></pre><p>}</p><p>装饰!!实例!!属性接收到的第一个参数为!!原型!!, 第二个参数为要装饰的属性名称<br>装饰!!静态!!属性接收到的第一个参数为!!类!!,   第二个参数为要装饰的属性名称</p><p>Person.prototype.setname(100)<br>Person.prototype.getname()      //100</p><p>静态方法直接调，静态方法需要prototype<br>实例方法可以直接调用</p><p>##装饰器传参</p><p>@send(135)<br>class Person{}</p><p>在装饰器后面添加需要传入的参数</p><p>function send(a:number){<br>    return function(target:any){<br>        console.log(a);              //135<br>        console.log(target)          //Person<br>    }</p><p>}</p><p>装饰函数的外层接收这个参数，内层接收这个类，这样就可以在装饰函数内部使用这个参数了</p><p>##举例<br>方法一：<br>// 装饰器工厂, 专门用来装饰方法<br>function getDecorator() {<br>    return function(…arg: any[]) {</p><pre><code>    let oldFn = arg[2].value;  // 缓存旧方法    console.log(oldFn);    // 装饰方法自动接收的第三个参数为描述对象,该对象有个value属性,可以获取被装饰的方法自身    // 把旧的方法替换成新的方法, 新的方法会记录执行时间    arg[2].value = function(count: number) {        let startTime = Date.now();     // 记录方法执行的开始时间        oldFn(count);        console.log(Date.now() - startTime);   // 打印方法执行所需的时间    };}</code></pre><p>}</p><p>方法二：<br>// 时间统计的装饰器<br>function time(target: any, name: string, msg: any) {<br>    // 保存旧方法<br>    let oldFn = msg.value;  </p><pre><code>// 替换成新方法msg.value = function() {    let startTime = Date.now();    oldFn();    console.log(Date.now() - startTime);}</code></pre><p>}</p><p>类：</p><p>class Dog {</p><pre><code>@time           //调用工厂函数需要加（）static loop() {    for(let i = 0; i &lt; 3000; i++) {        console.log(&apos;跑起来&apos;);    }}</code></pre><p>}</p><p>Dog.loop();  </p><p>#Typescript转es5<br>在项目文件夹打开终端tsc –init<br>将 “experimentalDecorators”: true打开，注意逗号<br>配置好之后，每次只需要在终端中tsc就可以了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#装饰器&lt;br&gt;装饰器本质上就是一个函数&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ES7" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/ES7/"/>
    
      <category term="装饰器" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/ES7/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
    
      <category term="装饰器" scheme="https://github.com/ztopia/ztopia.github.io.git/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>异步终极处理方案之async</title>
    <link href="https://github.com/ztopia/ztopia.github.io.git/2017/05/25/%E5%BC%82%E6%AD%A5%E7%BB%88%E6%9E%81%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88%E4%B9%8Basync/"/>
    <id>https://github.com/ztopia/ztopia.github.io.git/2017/05/25/异步终极处理方案之async/</id>
    <published>2017-05-25T12:19:21.000Z</published>
    <updated>2017-11-26T01:29:31.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异步终极处理方案之async"><a href="#异步终极处理方案之async" class="headerlink" title="异步终极处理方案之async"></a>异步终极处理方案之async</h1><a id="more"></a><p>在ES6中新增了promise来处理异步操作，这种方案将以前的嵌套式异步处理方式改为平铺式，方便代码的维护和管理，随着ES7的到来，async给我们带了更好的代码编写体验。本文先从promise讲起。</p><p>##使用promise进行异步处理</p><pre><code>new Promise(function(yes, no) {    $(&apos;div&apos;).animate({ width: 200 }, 1000, function() {        yes();    });}).then(function() {    return new Promise(function(yes, no) {        $(&apos;div&apos;).animate({ height: 200 }, 1000, function() {            yes();        });    });})//这里在使用Promise创建出来的实例的时候，可以将这一部分进行封装function animate(selector, style, time) {    return new Promise(function(yes, no) {        $(selector).animate(style, time, function() {            yes();        });    });}</code></pre><p>##使用asnyc进行异步处理    </p><pre><code>//先将实例对象进行封装function animate(selector,obj,time){    return new Promise(function(yes,no){        $(selector).animate(obj,time,function(){                yes();          })    })}async function run(){    await animate(&quot;div&quot;,{width:400},500);    await animate(&quot;div&quot;,{marginTop:300},500);}  run().catch(=&gt;{console.log(404 Error)})</code></pre><p>##检错</p><pre><code>-当调用no()时，可以使用catch()来进行捕获</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;异步终极处理方案之async&quot;&gt;&lt;a href=&quot;#异步终极处理方案之async&quot; class=&quot;headerlink&quot; title=&quot;异步终极处理方案之async&quot;&gt;&lt;/a&gt;异步终极处理方案之async&lt;/h1&gt;
    
    </summary>
    
      <category term="前端" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ES6" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/ES6/"/>
    
      <category term="异步处理" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/ES6/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"/>
    
    
      <category term="异步处理" scheme="https://github.com/ztopia/ztopia.github.io.git/tags/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>移动web</title>
    <link href="https://github.com/ztopia/ztopia.github.io.git/2017/01/17/%E7%A7%BB%E5%8A%A8web/"/>
    <id>https://github.com/ztopia/ztopia.github.io.git/2017/01/17/移动web/</id>
    <published>2017-01-17T13:58:26.000Z</published>
    <updated>2017-11-26T01:29:02.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="移动WEB"><a href="#移动WEB" class="headerlink" title="移动WEB"></a>移动WEB</h1><a id="more"></a><h2 id="向下覆盖，向上兼容"><a href="#向下覆盖，向上兼容" class="headerlink" title="向下覆盖，向上兼容"></a>向下覆盖，向上兼容</h2><p>css样式大的写下面，样式就会向下覆盖</p><p>标签内col-md-5会使col-lg-5生效（不用写lg），这就是向上兼容</p><h2 id="自封装字体图标"><a href="#自封装字体图标" class="headerlink" title="自封装字体图标"></a>自封装字体图标</h2><p>1.icomoon.io –&gt;icomoon App –&gt;import Icon:选择需要封装的字体图标文件 –&gt;Generate Font  –&gt;Download</p><p>2.解压到文件夹，HTML引用style.css.需要什么图标直接使用类名即可</p><h2 id="CSS约定"><a href="#CSS约定" class="headerlink" title="CSS约定"></a>CSS约定</h2><p>最外层元素用id。尽量使用直接子代选择器（&gt;div &gt;a）</p><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>less预处理器</p><ol><li>变量  @变量名:变量值</li><li>嵌套  跟标签结构一样写CSS选择器结构  &amp;表示当前的元素</li><li>混合  定义函数 如果有参数 (形参:默认值)</li><li>注释 // 会被删除 /**/不会被删除</li><li>引入 @import “demo.less”;</li></ol><h2 id="原生移动端"><a href="#原生移动端" class="headerlink" title="原生移动端"></a>原生移动端</h2><p>由于分辨率的原因，所有移动端的图片大小都缩小一半</p><p>为了显示页面的大气，在每一部分加适当的padding。</p><p>在所有浮动了父元素上加class=”clearfix”。</p><p>.clearfix::before,<br>.clearfix::after {</p><pre><code>content: &quot;&quot;;display: block;clear: both;</code></pre><p>}</p><p>a便签先转块</p><p>响应式宽高都不要写死，用百分比，定位也是，但是父元素要有定位</p><h3 id="1-建立主体结构"><a href="#1-建立主体结构" class="headerlink" title="1.建立主体结构"></a>1.建立主体结构</h3><p>index.html</p><p>css</p><p>js</p><p>less</p><p>img</p><p>lib(外部引用包)</p><h3 id="2-引入less"><a href="#2-引入less" class="headerlink" title="2.引入less"></a>2.引入less</h3><p>先写base.less,</p><p>再写index.less,</p><p>在index.less中@import “base.less”</p><p>html中引入base.less和index.less,最后引入less.js，注意在在引入base.less时， rel=”stylesheet/less”</p><h3 id="3-左右固定，中间自适应"><a href="#3-左右固定，中间自适应" class="headerlink" title="3.左右固定，中间自适应"></a>3.左右固定，中间自适应</h3><p>大盒子不能写死宽度,100%即可。左右两个盒子写死宽度，分别定位到左右两边，中间盒子宽度100%。</p><h3 id="4-Slider"><a href="#4-Slider" class="headerlink" title="4.Slider"></a>4.Slider</h3><p>因为响应式，所以不写死宽高，用百分比表示</p><p>1.多加两张图片，第一张放最后，最后一张放第一。</p><h3 id="5-原生移动端JS"><a href="#5-原生移动端JS" class="headerlink" title="5.原生移动端JS"></a>5.原生移动端JS</h3><p>用window.addEvenListener(“load”,function(){   调用函数 })</p><p>1.window.addEventListener(“事件名称”,function{代码段})</p><p>2.DOM.addEventListener(“事件名称”,function(){代码段})</p><p>事件名称：</p><p>window : scroll;</p><p>Dom : transitionend ;                  </p><pre><code>touchstart ;touchmove ; touchend      &gt;&gt;e.touches[0]</code></pre><p>​ sliderUI.addEventListener(“touchmove”, function(e) {</p><pre><code>    moveX = e.touches[0].clientX;    distanceX = moveX - startX;    sliderUI.style.transform = &quot;translateX(&quot; + (-index * sliderWidth + distanceX) + &quot;px)&quot;    sliderUI.style.transition = &quot;none&quot;;})</code></pre><h2 id="屏幕适配问题"><a href="#屏幕适配问题" class="headerlink" title="屏幕适配问题"></a>屏幕适配问题</h2><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>root element</p><p>em: 当前元素font-size:16px,1em=16px</p><p>rem:html元素font-size:16px,1rem=16px</p><p>html {  font-size:16px }          这个不是用来设置字体大小的，而是用来做屏幕适配</p><p>而body { font-size :12px }      这个才是设置字体大小的，要设置</p><p>div { width:10rem}      width:160px</p><p>步骤：按照设计稿写死数据，使用rem工具生成媒体查询代码，注意补充body{}</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;移动WEB&quot;&gt;&lt;a href=&quot;#移动WEB&quot; class=&quot;headerlink&quot; title=&quot;移动WEB&quot;&gt;&lt;/a&gt;移动WEB&lt;/h1&gt;
    
    </summary>
    
      <category term="移动web" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E7%A7%BB%E5%8A%A8web/"/>
    
    
      <category term="移动web" scheme="https://github.com/ztopia/ztopia.github.io.git/tags/%E7%A7%BB%E5%8A%A8web/"/>
    
      <category term="rem" scheme="https://github.com/ztopia/ztopia.github.io.git/tags/rem/"/>
    
  </entry>
  
  <entry>
    <title>Typescript</title>
    <link href="https://github.com/ztopia/ztopia.github.io.git/2016/11/21/Typescript/"/>
    <id>https://github.com/ztopia/ztopia.github.io.git/2016/11/21/Typescript/</id>
    <published>2016-11-21T09:15:29.000Z</published>
    <updated>2017-11-26T01:28:40.927Z</updated>
    
    <content type="html"><![CDATA[<p>#typescript<br><a id="more"></a></p><p>##ts中实例的属性必须先定义, 后面才能赋值<br>        public name: string;<br>        private readonly age: number;<br>number类型<br>string类型<br>boolean类型<br>undefined类型<br>null类型<br>undefined类型的变量只能赋值为undefined,null类型的变量只能赋值为null<br>undefined与null可以赋值给其他类型<br>    public name: string;<br>    private readonly age: number;</p><p>##数组<br>let numArr: number[] = [1, 2, 3];<br>let strArr: string[] = [‘a’, ‘b’, ‘c’];<br>let bolArr: boolean[] = [true, false];<br>let undifArr: undefined[] = [undefined];<br>let nulArr: null[] = [null];</p><p>联合型<br>let arr1: (number|string)[] = [1, 2, ‘abc’, ‘cba’, 4, 5];</p><p>任意型<br>let anyArr: any[] = [1, ‘abc’, true, null, undefined];</p><p>枚举<br>// 如果你要定义一组固定不变的对象, 那么请声明为枚举类型<br>// 如果使用传统的const方式定义枚举, 只是限制了变量的引用不可变,但对象的属性仍然是可变的<br>    const gender = [‘男’, ‘女’];<br>    gender.push(‘中性’);<br>// 如果你要定义一组固定不变的对象, 那么请声明为枚举类型<br>    enum gender2 { ‘男’, ‘女’ };</p><p>##函数<br>参数与返回值类型<br>function sum(a: number, b?: number, c: number = 50): number  {<br>    return b? a + b: a;                       函数返回值类型（number）<br>}</p><p>sum(5);                    // 正常,问好可有可无<br>sum(5, 8, 10);          // 正常，第三个参数是默认值为50<br>sum(5, 8, 10, 20);     // 报错</p><p>无返回值<br>function log(msg): void {<br>    console.log(msg);<br>    return 10;                // 报错<br>}</p><p>##class实例属性简写<br>    class Dog {<br>        constructor(public name: string, public age: number) {}<br>    }</p><pre><code>let d: Dog = new Dog(&apos;中华田园犬&apos;, 20);console.log(d.name);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;#typescript&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Typescript" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/Typescript/"/>
    
    
      <category term="Typescript" scheme="https://github.com/ztopia/ztopia.github.io.git/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>ES6语法以及API</title>
    <link href="https://github.com/ztopia/ztopia.github.io.git/2016/10/27/ES6%E8%AF%AD%E6%B3%95%E4%BB%A5%E5%8F%8AAPI/"/>
    <id>https://github.com/ztopia/ztopia.github.io.git/2016/10/27/ES6语法以及API/</id>
    <published>2016-10-27T08:44:39.000Z</published>
    <updated>2017-11-26T01:28:27.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><a id="more"></a><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>不允许重复定义</p><p>*块 级作用域：在块中使用let定义的变量。在外部无法使用</p><p>*没有预解析</p><p>暂时性死区：如果在一个作用域中使用了某个变量，在外部无法使用，即使在前面也定义了这个变量</p><p>全局变量不再是window对象</p><p>eg:</p><p>  let i=0;<br>  {</p><pre><code>console.log(i)  //报错，块级作用域，暂时性死区，变量预解析let i=2;</code></pre><p>  }<br>  console.log(i);    //注释第一个，值为0，块级作用域</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>定义常量必须赋值，并且不能修改</p><p>不允许重复定义</p><p>*块 级作用域：在块中使用let定义的变量。在外部无法使用</p><p>*没有预解析</p><p>暂时性死区：如果在一个作用域中使用了某个变量，在外部无法使用，即使在前面也定义了这个变量</p><p>全局变量不再是window对象</p><h2 id="赋值解构"><a href="#赋值解构" class="headerlink" title="赋值解构"></a>赋值解构</h2><p>按照相同的模式从数组或对象提取赋值给其他变量</p><p>数组：</p><p> let arr=[1,2,3,4,5,6,7];<br>  [,a,,,,,b]=arr;                 //数组是有序的</p><p>对象：</p><p>let {c:CC,d}={a:1,b:2,c:3,d:[2,1],e:{e1:2,e2:3}}        //CC重命名变量</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="``字符串"></a>``字符串</h2><p>模版字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 可以访问变量、调用函数、及各种表达式运算</span><br><span class="line">var mei = &#123;</span><br><span class="line">  name: &apos;小美&apos;,</span><br><span class="line">  age: 16</span><br><span class="line">&#125;;</span><br><span class="line">let str = `$&#123; mei.name &#125;今年$&#123; mei.age &#125;了，</span><br><span class="line">  还有$&#123; 30 - mei.age &#125;年他就30了`;</span><br><span class="line">console.log(str);</span><br></pre></td></tr></table></figure><h2 id="…运算符"><a href="#…运算符" class="headerlink" title="…运算符"></a>…运算符</h2><p>解或者和数组，伪数组</p><h2 id="函数-gt"><a href="#函数-gt" class="headerlink" title="函数=&gt;"></a>函数=&gt;</h2><p>let ale=(param)=&gt;{}</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>=&gt;没有this，他的this是它的上一级作用域中的this指向，用forEach遍历时，第二个参数无效</p><p>=&gt;不能new</p><p>=&gt;不能使用arguments</p><p>=&gt;函数中this固定指向的上一级this</p><pre><code> // 这里this打印{},因为被第二个参数指定了numSet.forEach(function(v) {    console.log(v, this);}, {});// 这里this打印window,因为取的是上级作用域thisnumSet.forEach(v =&gt; console.log(v, this), {});</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Tab() &#123;</span><br><span class="line">  this.tabBtn = document;</span><br><span class="line">  this.tabBox = document.body;</span><br><span class="line">&#125;</span><br><span class="line">Tab.prototype = &#123;</span><br><span class="line">  on: function() &#123;</span><br><span class="line">      this.tabBtn.onclick = () =&gt; &#123;</span><br><span class="line">          console.log(this);//点击后指向Tab</span><br><span class="line">          this.tabBox.style.backgroundColor = &apos;blue&apos;;</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">new Tab().on();</span><br></pre></td></tr></table></figure><p>​</p><pre><code>  fn: function() {  // 使用箭头函数,回调里面的this就指向了上级的tab实例   // 相比以前我们不用再通过一个临时变量存储外界this值了,比如var that = this;   setTimeout(() =&gt; {            //默认是window的对象      console.log(this);   }, 1000);}</code></pre><p>其他this：</p><p>​    // 关于这个this// this为window: 普通自调函数 传入定时器的普通函数 函数名()</p><p>​    // this为宿主对象: 对象.方法()</p><p>​    // this为实例对象: new 普通函数()</p><p>​    // this为任意值: 函数.call(指定this的指向)</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>​    let arr = [ 1, 3, 5, 7, 9 ];</p><p>​     // 解题1,通过forEach实现</p><pre><code>arr.forEach( (v, i) =&gt; arr[i] = v * 3 );    //forEach只是遍历// 解题2,通过map实现,map本身的作用就是通过一组数据映射为另一组数据arr = arr.map( v =&gt; v * 3 );                //map直接返回映射后的数组</code></pre><h2 id="对象优化"><a href="#对象优化" class="headerlink" title="对象优化"></a>对象优化</h2><p>1.</p><p>let obj = {</p><pre><code>    a,    fn};</code></pre><p>2.</p><p>let obj2 = {</p><pre><code>    fn: function() {        console.log(&apos;以前的写法&apos;);    },    fn2() {        console.log(&apos;es6新的写法&apos;);    }};</code></pre><p>3.key使用表达式</p><p> let varName = ‘xxx’;</p><pre><code>let obj3 = {    a: 10,    b: 20,    [varName + &apos;xxx&apos; + &apos;ooo&apos;]: 30};</code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="静态成员和实例成员"><a href="#静态成员和实例成员" class="headerlink" title="静态成员和实例成员"></a>静态成员和实例成员</h3><p>有构造函数构造 出来的成员为实例成员</p><p>由类创建出来的成员是静态成员         Animal.max_age=10000</p><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>类本质上还是一个函数</p><p>类中的实例方法都定义在了原型中</p><p>类中的静态方法都定义在了自身</p><pre><code>// 定义了动物类   class Animal {   // 这是构造器    constructor(name, age) {        this.name = name;        this.age = age;    }    // 这个方法相当于以前加到原型上的实例方法    eat() {        console.log(&apos;吃吧&apos;);    }    // 这个方法相当于以前加到原型上的实例方法    run() {        console.log(&apos;跑吧&apos;);    }    // 这个方法加了static修饰符,就是以前加到类身上的静态方法    static getAnimal(...arg) {        return new Animal(...arg);    }}var mao = new Animal(&apos;猫咪&apos;, 5);console.log(mao.name);console.log(mao.age);mao.eat();mao.run();// 静态方法由类名直接调用var bao= Animal.getAnimal(&apos;宝宝&apos;, 8);console.log(bao.name);</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>extends:</p><pre><code>class Dog extends Animal {  eat() {        console.log(&apos;吃屎&apos;);    }}</code></pre><p>super:</p><pre><code>constructor(name, gender, price) {       super(name, gender);     // 如果继承的子类拥有独特的属性,需要写构造器来添加,                               // 但是构造器里面的第一句话必须是super()调用       this.price = price; }</code></pre><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Number-内置构造函数"><a href="#Number-内置构造函数" class="headerlink" title="Number 内置构造函数"></a>Number 内置构造函数</h3><p>Number.isInteger()                    //是否为整型</p><p>Number.isNaN()                    //是否为NaN</p><p>Number.isFinite(Math.pow(999999, 999999))   //false            是否为有限数</p><h3 id="String内置构造函数"><a href="#String内置构造函数" class="headerlink" title="String内置构造函数"></a>String内置构造函数</h3><p>String.prototype是实例对象就是str</p><p>String.fromCodePoint()                //根据ASCII显示对应数值</p><p>String.prototype.codePointAt:</p><pre><code>let str = &apos;ABC&apos;;console.log(str.codePointAt(1));  // 获取下标为1字符的编码   66</code></pre><p>String.prototype.charAt:</p><pre><code>let str = &apos;ABC&apos;;console.log(str.charAt(2)); // C     下标为2的值</code></pre><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Object.assign(o1,o2,o3)                        //将后面的对象的第一层 复制给o1对象（也包括o1本身）</p><p>Object.keys()                        //获取对象的key值</p><p>Object.values()                    //获取对象的value值</p><p>Object.entries()                    //以二维数组的形式获取对象的key和value</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>找到第一个符合条件的值</p><p>let arr=[1,2,3]</p><p>let x=arr.find(v=&gt;{v&lt;2})                //找到数组中小于2的第一个数</p><h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h3><p>找到第一个符合条件的值得下标</p><p>let y=arr.findIndex(function(v){v&lt;2})</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>找到符合条件的所有值</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>值唯一</p><p>let num=new Set([1,2,1,3])            //自动过滤掉重复的值</p><p>​    num.size</p><p>​    num.add(“news”)                //新增内容</p><p>​    num.delete(‘news’)                //删除某个内容</p><p>​    num.has(‘2’)                    //检测某个数组中是否含有某个值</p><p>​    num.clear()                    //清除所有的值</p><h3 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h3><p>for (let a of [1,2,3])</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">传统对象的key值，最终都是字符串</span><br><span class="line">// let obj = &#123;</span><br><span class="line">//     document: 100,</span><br><span class="line">//     [a]: 200//这里的[a]</span><br><span class="line">// &#125;;</span><br><span class="line">// console.log(obj);  // &#123; document: 100, [object Object]: 200 &#125;</span><br></pre></td></tr></table></figure><p>用来遍历数组和伪数组，也支持由Set和Map创建（new）出来的数组</p><p>for in 遍历对象</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>类似于传统对象,特点是key可以是任意东西：</p><pre><code>let map = new Map([     [1, 100],    [&apos;abc&apos;, 200],    [Date, 300],    [{}, 400]]);</code></pre><p>get:</p><p> console.log(map.get({}));   // undefined,因为传入的{}是新的，对象看存储地址</p><p>set:</p><pre><code>let obj = {};map.set(obj, 500);</code></pre><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><p>第一步：new Promise</p><p>​    let p=new Promise(    (yes,no)=&gt;{代码段：调用yes()/no()    } )</p><p>第二步：调用实例then</p><p>​     p.then(</p><p>​        ()=&gt;{代码段},            //yes</p><p>​        ()=&gt;{代码段}            //no                    //要写两个函数，注意顺序</p><p>​    )</p><p>​    .catch(</p><p>​        ()=&gt;{代码段}            //所有no调用的内容</p><p>​    )</p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>如果需要执行多次调用</p><pre><code>let p = new Promise(function(yes, no) {   setTimeout(() =&gt; {        yes();    }, 2000);});// 上一个定时器执行完毕后, 开启下一个定时器p.then(function() {    console.log(&apos;第一个计时器回调执行，开启第二个&apos;);    // 为了可以在外面调用该实例的then方法,只要return出去就可以了    return new Promise(function(yes, no) {        setTimeout(() =&gt; {            yes();        }, 2000);    });})// 如果then回调中返回的是promise实例,那么我们就可以链式编程得到它.then(function() {    console.log(&apos;第二个计时器回调执行，开启第三个&apos;);    // 为了可以在外面调用该实例的then方法,只要return出去就可以了    return new Promise(function(yes, no) {        setTimeout(() =&gt; {            yes();        }, 2000);    });}).then(function() {    console.log(&apos;第三个计时器回调执行, 完毕&apos;);});</code></pre><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><pre><code>function getTimeout(time) {    return new Promise(function(yes, no) {       setTimeout(() =&gt; {          yes(&apos;传哥&apos;);       }, time);    });}let p = getTimeout(5000); // 得到promise实例p.then(function(data){    console.log(`第一个计时器回调执行，开启第二个____${data}`);    return getTimeout(3000);}).then(function(data) {    console.log(`第二个计时器回调执行，开启第三个____${data}`);    return getTimeout(1000);}).then(function() {    console.log(&apos;第三个计时器回调执行, 完毕&apos;);});</code></pre><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><pre><code>function pmsTimeout(time, data) {    return new Promise(function(yes, no) {    setTimeout(function() {        yes(`Hello ${ data }`); // 数据小做处理    }, time);});</code></pre><p>}</p><h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">async function asyncTimeout() &#123;</span><br><span class="line">    let data = null;  //记录每一次异步操作</span><br><span class="line"></span><br><span class="line">    data = await pmsTimeout(1000, &apos;大哥&apos;);</span><br><span class="line">    console.log(data);</span><br><span class="line"></span><br><span class="line">    data = await pmsTimeout(2000, &apos;二哥&apos;);</span><br><span class="line">    console.log(data);</span><br><span class="line"></span><br><span class="line">    data = await pmsTimeout(3000, &apos;三弟&apos;);</span><br><span class="line">    console.log(data);</span><br><span class="line"></span><br><span class="line">    data =await pmsTimeout(4000, &apos;四弟&apos;);</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;</span><br><span class="line">//调用</span><br><span class="line">asyncTimeout();</span><br></pre></td></tr></table></figure><h3 id="数据请求"><a href="#数据请求" class="headerlink" title="数据请求"></a>数据请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">async function asyncFetch() &#123;</span><br><span class="line">    let response = null, data = null;</span><br><span class="line"></span><br><span class="line">    response = await fetch(&apos;zt.json&apos;);</span><br><span class="line">    data =  response.ok &amp;&amp; await response.json();</span><br><span class="line">    console.log(data);</span><br><span class="line"></span><br><span class="line">    response = await fetch(&apos;vue.js&apos;);</span><br><span class="line">    data = response.ok &amp;&amp; await response.text();</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">asyncFetch();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h1&gt;
    
    </summary>
    
      <category term="前端" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ES6" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/ES6/"/>
    
    
      <category term="ES6" scheme="https://github.com/ztopia/ztopia.github.io.git/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>require.js</title>
    <link href="https://github.com/ztopia/ztopia.github.io.git/2016/09/12/require-js/"/>
    <id>https://github.com/ztopia/ztopia.github.io.git/2016/09/12/require-js/</id>
    <published>2016-09-12T08:34:53.000Z</published>
    <updated>2017-11-26T01:27:53.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="require-js"><a href="#require-js" class="headerlink" title="require.js"></a>require.js</h1><a id="more"></a><p>异步组件定义：实现代码的异步动态加载，提高页面加载性能</p><p>导入require.js</p><p> -&gt;定义模块  define([],function(){})      //定义模块</p><p> -&gt; 调用模块 require([‘tab’],function(){})      –&gt;路径应该是一个字符串格式（tab.js）</p><pre><code>--&gt;路径不需要后缀名(requirejs只能加载js文件)--&gt;这样就能执行了tab.js模块里面的代码</code></pre><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>通过在require回调函数中，通过形参来获取当前模块的返回值</p><p>在js中return function(){}</p><p>通过require([‘tab’],function(tab){tab()})</p><h2 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h2><p><script src="require.js" data-main="main"></script>      //main.js</p><h2 id="是否支持AMD规范"><a href="#是否支持AMD规范" class="headerlink" title="是否支持AMD规范"></a>是否支持AMD规范</h2><p>搜索define.amd</p><p>不支持AMD规范肯定没有返回值</p><p>如果支持AMD规范，分析该功能的入口，看看该入口是不是由该文件自己提供的</p><p>jquery插件支持AMD规范但是没有返回值 ，给返回值的目的是给一个功能入口（没有返回值，不能使用依赖注入）</p><p>if(typeof define==’function’ &amp;&amp; define.amd){</p><p>​ define([],function(){</p><p>​   return v8</p><p>​ })</p><p>​ window.v8=v8;</p><p>}</p><p>在第三方模块中加入以上代码就支持了amd规范</p><h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p>1.直接调用文件（优先级最低）</p><p>注意调用文件时的路径</p><p>2.通过入口文件调用（优先级第二高）</p><p><script src="require.js" data-main="js/"></script>   此时文件路径基于js文件夹</p><p>3.通过自定义文件定义路径（优先级最高）</p><p>require.config({</p><pre><code>    //配置基础路径        --&gt;以后所有的模块路径都是基于该基础路径的    baseUrl:&quot;js&quot;      //相对于index.html的路径    paths:{      &apos;jquery&apos;:&apos;lib/jquery-1.2.4&apos;   //配置特定文件的路径，基于baseUrl      &apos;asset&apos;:&apos;asset&apos;           //配置指定文件夹路径    }    shim:{    }});</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;require-js&quot;&gt;&lt;a href=&quot;#require-js&quot; class=&quot;headerlink&quot; title=&quot;require.js&quot;&gt;&lt;/a&gt;require.js&lt;/h1&gt;
    
    </summary>
    
      <category term="前端" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="require.js" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/require-js/"/>
    
    
      <category term="require.js" scheme="https://github.com/ztopia/ztopia.github.io.git/tags/require-js/"/>
    
      <category term="模块化开发" scheme="https://github.com/ztopia/ztopia.github.io.git/tags/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>canvas</title>
    <link href="https://github.com/ztopia/ztopia.github.io.git/2016/08/30/canvas/"/>
    <id>https://github.com/ztopia/ztopia.github.io.git/2016/08/30/canvas/</id>
    <published>2016-08-30T05:20:29.000Z</published>
    <updated>2017-11-26T01:26:50.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h1><a id="more"></a><h2 id="基本图形绘制"><a href="#基本图形绘制" class="headerlink" title="基本图形绘制"></a>基本图形绘制</h2><p>var canvas=document.querySelector(“#canvas”)</p><p>var context=canvas.getContext(‘2d’)</p><p>context.moveTo(x,y)   //落笔点</p><p>context.lineTo(x,y)     //连线</p><p>context.beginPath()     //启用一张新的玻璃纸</p><p>context.closePath()     //自动闭合路径</p><p>context.lineWidth=19</p><p>context.strokeStyle=’red’</p><p>context.stroke()</p><p>context.fillStyle=’blue’</p><p>context.shadowOffsetX=13      //shadow</p><p>context.shadowOffsetY=13</p><p>context.shadowColor=’red’</p><p>context.shadowBlur=12       //shadow模糊程度</p><p>context.fill()</p><p>context.rect(x,y,width,height)</p><p>context.strokeRect(x,y,width,height)  //只能描边</p><p>context.fillRect(x,y,width,height)    //只能填充</p><p>context.arc(x,y,radius,startRadian,endRadian,direction)   //     angle/180*Math.PI   direction默认false顺时针</p><p>context.setLineDash([x,y,z])      //每一段的长度，包括虚实</p><p>context.setDashOffset()   //虚线位便宜</p><p>context.lineCap=’round’                   //圆型帽</p><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><p>var gradient=context.createLinearGradient(x,y,x1,y1)                //x,y起始坐标,x1,y1结束坐标</p><p>​ gradient.addColorStop(offset,color)       //offset百分比0-1</p><p>​ context.fillStyle=gradient</p><p>​ context.fillRect=(x,y,w,h)          //x,y只要包括上面的x,y就可以</p><h3 id="镜像渐变"><a href="#镜像渐变" class="headerlink" title="镜像渐变"></a>镜像渐变</h3><p>以内圆的边为起点，外圆的边为终点做渐变</p><p>var gradient=context.createRadiaGradient(x0,y0,r0,x1,y1,r1);</p><p>​ gradient.addColorStop(offset,color)</p><p>​ context.fillStyle=gradient</p><p>​ context.arc(x0,y0,r0);</p><p>​ context.arc(x1,y1,r1);</p><p>​ context.fill();</p><h3 id="非0填充"><a href="#非0填充" class="headerlink" title="非0填充"></a>非0填充</h3><p>只会填充非0部分，direction相反的话不填充。射线是偶数条才可能不填充</p><h3 id="文字对齐方式"><a href="#文字对齐方式" class="headerlink" title="文字对齐方式"></a>文字对齐方式</h3><p>水平对齐的文字坐标原点在文字的左下角，设置完对齐方式后自动对齐</p><p>context.font=’50px 微软雅黑’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.fillText(&quot;hello, world&quot;, 100, 100);</span><br><span class="line">context.strokeText(&quot;hello, world&quot;, 100, 100);</span><br></pre></td></tr></table></figure><p>文本测量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var measureResult = context.measureText(&quot;hello, world&quot;).width;</span><br></pre></td></tr></table></figure><p>水平对齐</p><p>context.textAlign=‘left/right/center’                  // 参考线在文本的左右中，默认底对齐</p><p>垂直对齐</p><p>context.textBaseline=‘top/bottom/middle’  //参考线在文本的上下中</p><h3 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h3><p>var image=new Image();</p><p>image.src=’path’;</p><p>image.onload=function(){      //等待图片加载完再运行程序</p><p>​ context.clearRect(x,y,w,h)    //清除画布的某个区域</p><p>​ 三参：context.drawImage(image,x,y)</p><p>​ 五参：context.drawImage(image,x,y,w,h) //缩放展示图片</p><p>​ 九参：context.drawImage(image,x0,y0,,w0,y0,x1,y1,w1,h1)    //从图片的x0,y0点开始切一个大小为w0,h0的图片，放在新得区域里，图片自动拉伸</p><p>}</p><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>context.scale(a,b)              //横竖坐标同时扩大x,y倍</p><p>context.translate(x,y)            //将坐标原点移动到x,y</p><p>context.rotate(angle)           //将坐标围绕坐标原点旋转angle度数</p><p>context.save()                //保存之前所有context操作</p><p>context.beginPath()             //开始路径</p><p>context.restore()             //恢复save()中的操作</p><p>window.requestAnimationFrame(draw)      //自动刷新动画，有返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.cancelAnimationFrame(返回值); 停止动画</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;canvas&quot;&gt;&lt;a href=&quot;#canvas&quot; class=&quot;headerlink&quot; title=&quot;canvas&quot;&gt;&lt;/a&gt;canvas&lt;/h1&gt;
    
    </summary>
    
      <category term="前端" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="canvas" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/canvas/"/>
    
    
      <category term="canvas" scheme="https://github.com/ztopia/ztopia.github.io.git/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="https://github.com/ztopia/ztopia.github.io.git/2016/08/22/git/"/>
    <id>https://github.com/ztopia/ztopia.github.io.git/2016/08/22/git/</id>
    <published>2016-08-22T04:38:22.000Z</published>
    <updated>2017-11-26T01:26:53.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><a id="more"></a><h2 id="Dash命令行"><a href="#Dash命令行" class="headerlink" title="Dash命令行"></a>Dash命令行</h2><p>pwd：当前文件夹路径</p><p>ls:当前文件夹内容例举</p><p>ls –hlep:帮助代码</p><p>cd:进入文件夹    cd-   cd../退后</p><p>cat:查看文件内容</p><p>ls  -a:显示所有文件</p><p>ls  -l:显示文件细节</p><p>ls  -al:组合显示所有文件和细节</p><p>mkdir:建文件夹  （-p需要的话建立一个父文件夹   -r递归这个文件夹，在删除和复制中使用）</p><p>rmdir:删除文件夹（只能删除空文件夹，配合-r）</p><p>rm:删除文件（不可逆） -r 递归删除</p><p>touch:创建文件</p><p>cp:复制文件       cp 1.js ./z/2.js  复制重命名  -n不覆盖</p><p>mv:剪切文件     mv 1.js ./z/2.js  剪切重命名</p><p>vi:写入文件–》i开始写入，esc退出编辑模式     :w保存:q退出编辑</p><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>git init :初始化git文件夹</p><p>git add:将文件从工作区提交到暂存区</p><p>git add . :将<strong>当前文件夹</strong>的所有文件提交</p><p>git config –global user.name</p><p> git config –global user.email</p><p>git commit:将文件提交到主仓库  -m 备注</p><p>git push src master:将主仓库的文件提交到服务器仓库</p><p>git log: 查看提交日志</p><p>git status:  关注文件的状态</p><p>​ Untracked files 以下是新创建的文件，位于工作区</p><p>​ Changes to be committed 文件在暂存区</p><p>git remote add 变量名 src    ：保存服务器地址</p><p>git remote remove <name>:删除某个变量服务器地址</name></p><p>git remote rename oragin1 oragin2:将变量名改为oragin2</p><p>git remote –help</p><h3 id="二次开发"><a href="#二次开发" class="headerlink" title="二次开发"></a>二次开发</h3><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>1.</p><p>git clone src  自己新建的文件夹名     ：将服务器的代码下载到本地文件夹名的文件夹中，只能使用一次</p><p>cd 进入文件夹</p><p>touch 1.txt</p><p>git add .</p><p>git commit -m </p><p>git push src master</p><p>2.</p><p>mkdir app3</p><p>cd app3</p><p>git init</p><p>git pull src master</p><p>touch 1.txt</p><p>git add .</p><p>git commit -m </p><p>git push src master</p><h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><p>git pull src master  先下载</p><p>touch 2.txt</p><p>git add .</p><p>git commit -m</p><p>git push src master</p><h4 id="版本回滚"><a href="#版本回滚" class="headerlink" title="版本回滚"></a>版本回滚</h4><p>git log –oneline</p><p>git reset –hard 版本号</p><p>git reflog  ：所有日志包括最初的</p><p>git checkout –1.txt</p><p>git reset HEAD – 1.txt :将1.txt从暂存区回到工作区</p><h2 id="文件的4种状态"><a href="#文件的4种状态" class="headerlink" title="文件的4种状态"></a>文件的4种状态</h2><ul><li>新创建</li><li><p>已修改</p><ul><li>一旦某个文件被修改过了，那么通过git status查看的结果就是：红色的modified</li><li>如果通过git add 把该修改操作告诉了暂存区，那么通过git status查看的结果就是：绿色的modified</li><li>如果希望让同事知道你修改某个文件，那么应该执行以下操作：<ul><li>git add .</li><li>git commit -m 修改了</li><li>git push 服务器仓库地址 master</li></ul></li></ul></li><li><p>已删除</p><ul><li>如果一个文件被删除了，那么通过git status查看的结果就是：红色的deleted</li><li>如果通过git add 把该删除操作告诉了暂存区，那么通过git status查看的结果就是：绿色的deleted</li><li>如果希望让同事知道你删除某个文件，那么应该执行以下操作：<ul><li>git add .</li><li>git commit -m 删除了</li><li>git push 服务器仓库地址 master</li></ul></li></ul></li><li>待提交<ul><li>changes to be committed</li></ul></li></ul><h2 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h2><ul><li>第一种情况：git clone <a href="https://github.com/hahareg12345/git114.git">https://github.com/hahareg12345/git114.git</a><ul><li>会将项目代码下载到当前文件夹下面的git114文件夹</li></ul></li><li>第二种情况：git clone <a href="https://github.com/hahareg12345/git114.git">https://github.com/hahareg12345/git114.git</a> git114-2<ul><li>会将项目代码下载到当前文件夹下面的git114-2文件夹</li></ul></li></ul><h2 id="对某个项目进行二次开发的操作流程1"><a href="#对某个项目进行二次开发的操作流程1" class="headerlink" title="对某个项目进行二次开发的操作流程1"></a>对某个项目进行二次开发的操作流程1</h2><ul><li>将服务器中的代码下载到本地：git clone <a href="https://github.com/hahareg12345/git114.git">https://github.com/hahareg12345/git114.git</a> git114-2</li><li>进行到项目所在文件夹进行开发：cd git114-2</li><li>之后就重复以下步骤进行提交代码<ul><li>touch 1.txt</li><li>git add .</li><li>git commit -m 新创建</li><li>git push 服务器仓库地址 master</li></ul></li></ul><h2 id="对某个项目进行二次开发的操作流程2"><a href="#对某个项目进行二次开发的操作流程2" class="headerlink" title="对某个项目进行二次开发的操作流程2"></a>对某个项目进行二次开发的操作流程2</h2><ul><li>mkdir app3</li><li>cd app3</li><li>git init</li><li>git pull 服务器仓库地址 master (为了将本地和服务器进行关联，并且下载服务器代码)</li><li>之后就重复以下步骤进行提交代码<ul><li>touch 1.txt</li><li>git add .</li><li>git commit -m 新创建</li><li>git push 服务器仓库地址 master</li></ul></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>1、保存服务器地址<br>git remote add 变量名 url</p><p>2、版本回滚<br>git reset –head 版本号</p><p>3、查看版本回滚的操作日志<br>git reflog</p><p>4、在公司里面，领导让我对某个github的项目(地址：origin)进行二次开发，我要开发一个新功能(例如往服务器中添加test.html文件)，我应该执行哪些步骤才能将test.html文件提交到服务器中<br>git clone origin file-&gt;touch test.html -&gt;git add test.html -&gt; git commit -m 添加了test.html -&gt;git push src master</p><p>5、写出把一个文件隔离的操作步骤<br>touch .gitignore 将需要隔离的文件放入 .gitignore</p><p>6、如何删除一个服务器中的文件<br>git rm file -&gt;git commit -m 删除了文件file -&gt; git push src master</p><p>7、如何查看分支；并说明如何识别当前位于哪个分支<br>git branch 带*前缀的当前分支</p><p>8、切换分支<br>git checkout 分支名</p><p>9、删除分支<br>git branch -d </p><p>10、分支合并<br>git checkout master<br>git merge 分支名 -m 备注信息</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>git log :基于这次开发的次数都可看见</p><p>git reflog : 显示具体操作过程，提交，切换分支，</p><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>查看当前拥有的所有分支(带*前缀的是当前的分支)</p><h3 id="git-branch-分支名"><a href="#git-branch-分支名" class="headerlink" title="git branch 分支名"></a>git branch 分支名</h3><p>在当前分支下创建新分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--&gt;新分支会继承所有的当前分支到目前为止的所有代码</span><br></pre></td></tr></table></figure><h3 id="git-checkout-分支名"><a href="#git-checkout-分支名" class="headerlink" title="git checkout 分支名"></a>git checkout 分支名</h3><p>切换到指定分支下面去</p><h3 id="git-merge-m-备注信息"><a href="#git-merge-m-备注信息" class="headerlink" title="git merge -m 备注信息"></a>git merge -m 备注信息</h3><p>将指定分支合并到当前分支下</p><h3 id="git-branch-d-分支名"><a href="#git-branch-d-分支名" class="headerlink" title="git branch -d 分支名"></a>git branch -d 分支名</h3><p>删除指定的分支</p><h3 id="无论是创建分支还是合并分支时刻警醒当前位于哪个位置"><a href="#无论是创建分支还是合并分支时刻警醒当前位于哪个位置" class="headerlink" title="无论是创建分支还是合并分支时刻警醒当前位于哪个位置"></a>无论是创建分支还是合并分支时刻警醒当前位于哪个位置</h3><h3 id="对于一个仓库，如果没有任何本地提交，git-branch-没有结果"><a href="#对于一个仓库，如果没有任何本地提交，git-branch-没有结果" class="headerlink" title="对于一个仓库，如果没有任何本地提交，git branch 没有结果"></a>对于一个仓库，如果没有任何本地提交，git branch 没有结果</h3><h3 id="不要在本地分支上push代码"><a href="#不要在本地分支上push代码" class="headerlink" title="不要在本地分支上push代码"></a>不要在本地分支上push代码</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;GIT&quot;&gt;&lt;a href=&quot;#GIT&quot; class=&quot;headerlink&quot; title=&quot;GIT&quot;&gt;&lt;/a&gt;GIT&lt;/h1&gt;
    
    </summary>
    
      <category term="前端" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="git" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/git/"/>
    
    
      <category term="git" scheme="https://github.com/ztopia/ztopia.github.io.git/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>jquery</title>
    <link href="https://github.com/ztopia/ztopia.github.io.git/2016/07/15/jquery/"/>
    <id>https://github.com/ztopia/ztopia.github.io.git/2016/07/15/jquery/</id>
    <published>2016-07-15T08:35:47.000Z</published>
    <updated>2017-11-26T01:25:23.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h1><h2 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h2><a id="more"></a><p>$(function(){</p><p>})</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>与CSS的选择器一样，$(“选择器名”).eq(下标)         //firsr()或者last()伪类选择器</p><p>$(“input[type=bottom]”)</p><p>属性以什么值开头  li[属性名^=属性值]<br>属性以什么值结尾   li[属性名$=值]<br>属性里面有没有某个值  li[属性名*=值]</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>js中事件不加om</p><p>.mouseenter(function(){代码段})</p><h2 id="效果函数"><a href="#效果函数" class="headerlink" title="效果函数"></a>效果函数</h2><p>第一个参数：持续事件   ，第二个参数： swing和 linear  ，第三个参数回调函数</p><h3 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h3><p>新方法</p><p>  slideToggle()：<br>    切换下滑，原来没下滑的下滑，原来已经下滑的上滑<br>   html()：<br>    获取或设置标签内的内容   例如<a>  这中间的部分就是标签内的内容 </a><br>  text():<br>    标签中的文本<br>  parent()<br>    获取自己的父元素<br>  children()<br>    获取自己的所有子元素<br>    children(‘li’)<br>      找到自己子元素的所有li标签，不包括其他元素<br>  clone()<br>    克隆某个元素，就代表原来元素有什么属性，它克隆出来也有什么属性<br>    默认不包括事件<br>  fadeIn()<br>    用动画效果不透明<br>  fadeOut()<br>    用动画效果透明<br>  fadeTo()<br>    用动画效果透明到某个值<br>  fadeToggle()<br>    切换透明，原来不透明的透明，透明的不透明</p><h2 id="animate（）"><a href="#animate（）" class="headerlink" title="animate（）"></a>animate（）</h2><p>参数1：传一个对象，用键值对的形式，写出你想参与动画效果的属性和它的值<br>参数2：动画的持续时间<br>参数3：动画效果：swing或者linear<br>参数4：动画的回调函数<br>​           只支持数字为值的属性</p><h1 id="H5C3"><a href="#H5C3" class="headerlink" title="H5C3"></a>H5C3</h1><h2 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h2><p><nav> 表示导航</nav></p><p><header> 表示页眉</header></p><p><footer> 表示页脚</footer></p><p><section> 表示区块</section></p><p><article> 表示文章 如文章、评论、帖子、博客</article></p><p><aside> 表示侧边栏 如文章的侧栏</aside></p><p><figure> 表示媒介内容分组 </figure></p><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>email 输入email格式</p><p>tel 手机号码</p><p>url 只能输入url格式</p><p>number 只能输入数字</p><p>search 搜索框</p><h3 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h3><p>placeholder 占位符</p><p>autofocus 获取焦点</p><p>multiple 文件上传多选或多个邮箱地址</p><p>autocomplete 自动完成，用于表单元素，也可用于表单自身</p><p>form 指定表单项属于哪个form，处理复杂表单时会需要</p><p>novalidate 关闭验证，可用于<form>标签</form></p><p>required 验证条件，必填项</p><p>pattern 正则表达式 验证表单</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>1.data-info=”我是自定义属性”，通过Node.dataset[‘info’] 来获取</p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h2 id="1-1-多媒体"><a href="#1-1-多媒体" class="headerlink" title="1.1 多媒体"></a>1.1 多媒体</h2><p>方法：load()、play()、pause()</p><p>属性：currentSrc、currentTime、duration</p><p>事件：</p><p>音乐播放器</p><h2 id="1-2-拖拽"><a href="#1-2-拖拽" class="headerlink" title="1.2 拖拽"></a>1.2 <strong>拖拽</strong></h2><p>拖拽元素：</p><p>目标元素：</p><p>设置拖拽：draggable=”true”</p><p>事件监听：</p><p>ondrag、ondragstart、ondragleave、ondragend</p><p>ondragenter、ondragover、ondrop</p><p>数据传递：ev.dataTransfer.setData()、ev.dataTransfer.getData()</p><h2 id="1-3-历史"><a href="#1-3-历史" class="headerlink" title="1.3 历史**"></a>1.3 <strong>历史<em>**</em></strong></h2><p>pushState()</p><p>replaceState()</p><p>onpopstate</p><h2 id="1-4地理定位"><a href="#1-4地理定位" class="headerlink" title="1.4地理定位"></a>1.4地理定位</h2><p>geolocation.getCurrentPosition()</p><p>geolocation.watchPosition()</p><h2 id="1-5-Web存储"><a href="#1-5-Web存储" class="headerlink" title="1.5 Web存储"></a>1.5 Web存储</h2><p>window.sessionStorage</p><p>window.localStorage</p><p>setItem(key, value)</p><p>getItem(key)</p><p>removeItem(key)</p><p>clear()</p><p>key(n)</p><p>生命周期差异，存储空间差异</p><p>WebSQL、IndexDB</p><h3 id="1-6-keyframe-ae"><a href="#1-6-keyframe-ae" class="headerlink" title="1.6@keyframe   ae(){"></a>1.6@keyframe   ae(){</h3><p>​       from{}</p><p>​       to{}</p><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;jquery&quot;&gt;&lt;a href=&quot;#jquery&quot; class=&quot;headerlink&quot; title=&quot;jquery&quot;&gt;&lt;/a&gt;jquery&lt;/h1&gt;&lt;h2 id=&quot;入口函数&quot;&gt;&lt;a href=&quot;#入口函数&quot; class=&quot;headerlink&quot; title=&quot;入口函数&quot;&gt;&lt;/a&gt;入口函数&lt;/h2&gt;
    
    </summary>
    
      <category term="前端" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="jquery" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/jquery/"/>
    
    
      <category term="jquery" scheme="https://github.com/ztopia/ztopia.github.io.git/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>javascript</title>
    <link href="https://github.com/ztopia/ztopia.github.io.git/2016/06/22/javascript%E9%AB%98%E7%BA%A7%20/"/>
    <id>https://github.com/ztopia/ztopia.github.io.git/2016/06/22/javascript高级 /</id>
    <published>2016-06-22T04:38:22.000Z</published>
    <updated>2017-11-26T01:24:06.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="javascript高级"><a href="#javascript高级" class="headerlink" title="javascript高级"></a>javascript高级</h1><a id="more"></a><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ECMAScript 3  DOM BOM</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number  string  boolean</span><br></pre></td></tr></table></figure><h3 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object function Array Math  Date  RegExp  Number  String  Boolean</span><br></pre></td></tr></table></figure><h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><p>Number  String  Boolean</p><h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h3><p>delete只能移除普通类型的属性，arr，obj</p><h2 id="引用类型，值类型"><a href="#引用类型，值类型" class="headerlink" title="引用类型，值类型"></a>引用类型，值类型</h2><p>1.引用类型指向的是一个地址，地址里面的数据改变则会变化，无论是函数。对象，数组</p><p>2.值类型一旦赋值，再改变不会影响之前的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//var num1 = 10;</span><br><span class="line">//var num2 = num1;</span><br><span class="line">//num1 = 20;</span><br><span class="line">//console.log(num2); //10</span><br></pre></td></tr></table></figure><h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>判断基本数据类型除了null，以及函数</p><h3 id="Object-prototype-toString-call-判断类型"><a href="#Object-prototype-toString-call-判断类型" class="headerlink" title="Object.prototype.toString.call(判断类型)"></a>Object.prototype.toString.call(判断类型)</h3><p>返回值[object Array]</p><h3 id="toString-的返回值"><a href="#toString-的返回值" class="headerlink" title=".toString()的返回值"></a>.toString()的返回值</h3><p>Array    :    string</p><p>object    :    [object Object]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj[&#123;&#125;] = &quot;你看我能不能添加进去&quot;;</span><br><span class="line">console.log(obj[&quot;[object Object]&quot;]);//等效下面的</span><br><span class="line">console.log(obj[&#123;&#125;]);</span><br></pre></td></tr></table></figure><h2 id="基本数据类型和复杂数据类型运算"><a href="#基本数据类型和复杂数据类型运算" class="headerlink" title="基本数据类型和复杂数据类型运算"></a>基本数据类型和复杂数据类型运算</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果一个复杂的数据类型和一个基本的数据类型进行运算，会调用这个对象的valueOf方法，取他的原始值再和这个基本数据类型进行运算.</span><br><span class="line">如果valueOf取不到一个值，就调用这个对象的toString方法，得到的值再和这个基本数据类型进行运算。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">隐式转换中空的对象和数组为true，alert（），if(),while();for( in )存在隐式转换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//console.log([] == ![]); //true</span><br><span class="line">//[] == ![]</span><br><span class="line">//[] == !true</span><br><span class="line">//[] == false   //注意</span><br><span class="line">//[].valueOf() == false</span><br><span class="line">//[] == false</span><br><span class="line">//[].toString() == false</span><br><span class="line">//&quot;&quot; == false</span><br><span class="line">//false == false</span><br><span class="line">//true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//console.log(&#123;&#125; == !&#123;&#125;); //false</span><br><span class="line">//&#123;&#125; == !&#123;&#125;</span><br><span class="line">//&#123;&#125; == !true</span><br><span class="line">//&#123;&#125; == false</span><br><span class="line">//&#123;&#125;.valueOf() == false</span><br><span class="line">//&#123;&#125; == false</span><br><span class="line">//&#123;&#125;.toString() == false</span><br><span class="line">//&quot;[object Object]&quot; == false</span><br><span class="line">//true == false</span><br><span class="line">//false</span><br></pre></td></tr></table></figure><p>console.log(null==false)   //false         parseInt(null)=NaN</p><p>console.log(undefinedl==false)   //false         parseInt(undefined)=NaN</p><h2 id="in关键字"><a href="#in关键字" class="headerlink" title="in关键字"></a>in关键字</h2><h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><p>for(var key in obj){</p><p>​    key is string</p><p>​    obj[key]</p><p>}</p><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p>“属性名或者下标” in obj</p><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indexOf 返回的是对应元素的下标，如果不存在这个元素，返回-1</span><br></pre></td></tr></table></figure><h2 id="逻辑运算-：-amp-amp-和"><a href="#逻辑运算-：-amp-amp-和" class="headerlink" title="逻辑运算   ：  &amp;&amp;和||"></a>逻辑运算   ：  &amp;&amp;和||</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.逻辑与  找假： 如果参与逻辑与运算的第一个式子能够转换成布尔类型的false，那么整个逻辑与表达式的结果就是第一个式子的值，如果第一个式子不能转换成布尔类型的false的话，那么整个逻辑与表达式的结果就是第二个式子的值。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.逻辑或  找真：如果参与逻辑或运算的第一个式子能够转换成布尔类型的true的话，那么整个逻辑或表达式的结果就是第一个式子的值，如果第一个式子不能转换成布尔类型的true的话，那么整个逻辑或表达式的结果就是第二个式子的值。</span><br></pre></td></tr></table></figure><p>应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e = e || window.event;</span><br><span class="line">var value1 = document.getElementById(&quot;one&quot;)  &amp;&amp; document.getElementById(&quot;one&quot;).value</span><br></pre></td></tr></table></figure><h2 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h2><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>1.删除没有用var声明的变量，不能删除全局变量</p><p>2.移除对象中的属性（removeAttribute()方法只能移除dom对象中属性）</p><p>3.数组中：arr.pop(); //删掉最后一个</p><p>​          arr.push(); //往数组的最后一个添加元素</p><p>​          arr.shift(); //删掉第一个</p><p>​          arr.unshift(); //往数组的第一个添加元素</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法： try &#123;</span><br><span class="line">        有可能会出现异常的代码</span><br><span class="line">        throw &quot;你为什么不传一个数字捏？&quot;//自定义抛出异常</span><br><span class="line">     &#125;catch(e)&#123;</span><br><span class="line">        捕获到异常了之后要执行的处理-代码</span><br><span class="line">        e就是异常信息  //语法错误，不能捕获。</span><br><span class="line">     &#125;finally &#123;</span><br><span class="line">        不管有没有发生异常，都要执行的代码</span><br><span class="line">        释放资源的处理</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>一种编程的思维方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var iQuery = &#123;</span><br><span class="line">    getEle:&#123;</span><br><span class="line">      tag:function (tagName)&#123;</span><br><span class="line">        return document.getElementsByTagName(tagName);</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      id: function (id) &#123;</span><br><span class="line">        return document.getElementById(id);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    css:&#123;</span><br><span class="line">      setStyle: function (eles)&#123;</span><br><span class="line">        for(var i = 0 ; i &lt; eles.length; i++)&#123;</span><br><span class="line">          var ele = eles[i];</span><br><span class="line">          ele.style.border = &quot;1px solid red&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      getStyle: function () &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">   Animate:&#123;</span><br><span class="line">     animate: function () &#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   //关于事件的模块</span><br><span class="line">   //关于属性的模块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>封装  继承  多态</p><p> 封装：就是将功能封装整合在对象内，只对外界暴露指定的接口，外界在使用的时候，只需要考虑接口怎么用，而不需要考虑内部的具体实现。</p><p>继承：js中的继承  对象之间的继承。  一个对象如果想拥有其他对象的属性和方法，就可以使用继承。</p><p>js中没有多态</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>a.混入式继承</p><p>​     for(var key in wangjianlin){</p><p>​          wangsicong[key] = wangjianlin[key];</p><p>​      }</p><p>b.替换原型</p><p>​    ZhaNan.prototype = wangjianlin;</p><p>​    var wangsicong = new ZhaNan([“豆得儿”,”林更新”,”林立群”,”0009901”]);</p><p>c.混合式继承</p><p>​      for(var key in wangjianlin){</p><pre><code>ZhaNan.prototype[key] = wangjianlin[key];</code></pre><p>​        }</p><p>​      var wangsicong = new ZhaNan([“豆得儿”,”林更新”,”林立群”,”0009901”]);</p><p>​    简单封装：</p><p>​          function extend(method,obj){</p><p>​                for(var key in obj){</p><p>​                      method.prototype[key] = obj[key];</p><p>​                }</p><p>​          }</p><p>​         extend(GoodMan,wangjianlin);</p><p>d. var wangsicong = Object.create(wangjianlin); // 原型继承</p><p>实现一个兼容所有浏览器的 create 方法：</p><p>​        var create = function(obj) {</p><p>​        //思路：先判断浏览器是否支持 Object.create </p><p>​        //如果支持，就直接使用</p><p>​        //如果不支持，就自己实现！</p><p>​                if(typeof Object.create === “function”) {</p><p>​                                       return Object.create(obj);   }</p><p>​                 function F() {}</p><p>​        F.prototype = obj;</p><p>​        return new F();</p><h2 id="拓展内置对象"><a href="#拓展内置对象" class="headerlink" title="拓展内置对象"></a>拓展内置对象</h2><p>Array.prototype.mySort = function () {</p><p>​    for(var i = 0 ; i &lt; this.length-1; i++){</p><p>​      for(var j = 0 ; j &lt; this.length-i-1; j++){</p><p>​        if(this[j] &gt; this[j+1]){</p><p>​              var temp = this[j];</p><p>​              this[j] = this[j+1];</p><p>​              this[j+1] = temp;</p><p>​            }</p><p>​      }</p><p>​    }</p><p>  }                      //不安全</p><p>//安全拓展</p><p>  //a.自己定义一个数组的构造函数。</p><p>​      function MyArray(arr){</p><p>​            this.arr = arr;</p><p>​      }</p><p>  //b.给这个构造函数的原型，继承自一个空数组。继承数组的一些属性</p><p>​      MyArray.prototype = [];</p><p>  //c.给这个我们自定写的构造函数的，原型添加一个 我们要扩展的方法。</p><pre><code>MyArray.prototype.mySort = function () {</code></pre><p>​            for(var i = 0 ; i &lt; this.arr.length-1; i++){</p><pre><code>for(var j = 0 ; j &lt; this.arr.length-i-1; j++){      if(this.arr[j] &gt; this.arr[j+1]){</code></pre><p>​                              var temp = this.arr[j];</p><p>​                              this.arr[j] = this.arr[j+1];</p><p>​                              this.arr[j+1] = temp;</p><p>​                        }</p><p>​                  }</p><p>​            }</p><p>​      }</p><p>  //d.测试一下，利用我们自己写的构造函数创建一个对象。</p><pre><code>var arr = [11,20,18,70];</code></pre><p>​      var arr1 = new MyArray(arr);</p><p>​      arr1.mySort();</p><p>​      console.log(arr1);</p><p>  //捣乱的程序员B</p><pre><code>Array.prototype.mySort = function () {</code></pre><p>​        console.log(“我是来捣乱的….”);</p><p>​      }</p><p>​      var arr2 = new MyArray(arr);</p><p>​      arr2.mySort();</p><p>​      console.log(arr2);</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p> a.构造函数不需要返回值，会自动返回创建的那个对象。 如果是返回的简单的数据类型，会忽略；  如果返回的是复杂的数据类型，会把创建出来的那个对象给覆盖掉。</p><p> function Person(name,age){</p><p>​    this.name = name;</p><p>​    this.age = age;</p><p>​    console.log(this);</p><p>​    //return [];</p><p>  }</p><p> var pp =new Person(“琳琳”,20);       //由Person构造函数构造出来的对象</p><p>console.log(pp)               //返回对象  </p><p>Person();                         //如果没有new那么返回undefined，其中的this指戴window对象</p><h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p>伪数组。存放的是函数的实参</p><p>.callee  —-当前执行的这根函数，自调用函数的递归</p><p>.length—– 实参的个数，模拟函数的重载</p><h3 id="静态成员和实例成员"><a href="#静态成员和实例成员" class="headerlink" title="静态成员和实例成员"></a>静态成员和实例成员</h3><p>静态成员是构造函数点出来的属性</p><p>实例成员是实例化对象点出来的属性</p><h3 id="instanceOf"><a href="#instanceOf" class="headerlink" title=".instanceOf"></a>.instanceOf</h3><p>判断某个构造函数的原型是否在某个对象的原型链上</p><p>Object instanceOf Function   //true</p><h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><p>eval(需要执行的代码字符串)</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p> 原型其实就是一个对象。（object）</p><p>提供数据共享和实现继承。</p><p>创建任意的构造函数的时候，系统都会帮我们自动的创建一个和这个构造函数关联的对象，这个对象就是原型。</p><p>通过构造函数new创建出来的对象，都可以访问这个构造函数对应的原型中的成员。访问规则是先看构造函数中是否有这个属性，如果没有再去原型中查找。</p><p>因为一个对象对创建出来他的原型就定下来了，不会随着原型改变而改变。</p><p>构造函数不需要返回值</p><p>Object.prototype.sayHi    一般存放公共的属性</p><p>如果修改原型（把原型指向另外的一个对象） ；</p><p>根据构造函数创建出来的对象，访问原型中的成员，要注意这个对象是 修改原型之前创建的，还是修改原型之后创建的。要想访问新的原型中的属性，那么在创建对象的时候必须在原型创建之后</p><h3 id="测试原型属性"><a href="#测试原型属性" class="headerlink" title="测试原型属性"></a>测试原型属性</h3><p>. _ <em>proto</em> _两个杠</p><p>console.log(Cat.prototype === c1.<strong>proto</strong>); //true</p><h2 id="Object常用成员"><a href="#Object常用成员" class="headerlink" title="Object常用成员"></a>Object常用成员</h2><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title=".constructor"></a>.constructor</h3><p>指向原型对应的那个构造函数,判断对象是由哪个构造函数构造出来的。</p><p>console.log(Cat.prototype.constructor === Cat); //true</p><p> console.log(c1.<strong>proto</strong>.constructor === Cat);     //c1=new Cat(“11”,”11”)</p><p> 原型可以替换。原型替换之后，就丢失了constructor的指向。 可以补回来</p><p>​     Cat.prototype = {</p><pre><code>sb:&quot;sb&quot;,</code></pre><p>​      constructor:Cat           //添加.contructor属性</p><p>​      };</p><p>​      console.log(Cat.prototype.constructor === Cat); //true</p><h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title=".hasOwnProperty"></a>.hasOwnProperty</h3><p>判断有无指定属性   .hasOwnProperty(属性名)</p><h3 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title=".isPrototypeOf"></a>.isPrototypeOf</h3><p>对象1.isPrototypeOf.对象2               //对象1是否为对象2的原型</p><h3 id="propertyIsEnumerable-NaN"><a href="#propertyIsEnumerable-NaN" class="headerlink" title=".propertyIsEnumerable"></a>.propertyIsEnumerable</h3><p>对象.propertyIsEnumerable(属性名)   //该属性是否为自己提供的</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>函数是js中可以分割作用域，js中作用域是词法作用域</p><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>在一个函数中调用另外一个函数，看被调用的函数的变量关系：</p><p> var num = 123;<br>  function func1(){</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(num);</span><br></pre></td></tr></table></figure><p>  }<br>  function func2(){</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func1();</span><br><span class="line">var num = 456;</span><br></pre></td></tr></table></figure><p>  }<br>  func2();</p><p>不管执行那个作用域里面的代码之前，都会把这个作用域中的变量的声明提前到当前这个作用域的最顶端，赋值语句保留在原地。函数也是如此声明提前赋值留在原地。</p><p>变量提升在作用域提升，函数在函数内。</p><p>new和（）之间的部分是构造函数</p><h3 id="同名"><a href="#同名" class="headerlink" title="同名"></a>同名</h3><h4 id="变量同名"><a href="#变量同名" class="headerlink" title="变量同名"></a>变量同名</h4><p>后来者居上</p><h4 id="变量和函数同名"><a href="#变量和函数同名" class="headerlink" title="变量和函数同名"></a>变量和函数同名</h4><p>如果在输出这个名字之前的时候，变量就已经有值了，输出的就是这个变量的值。</p><p>如果在输出这个名字之前的时候，变量没有值，输出的就是这个同名的函数的函数体。</p><h4 id="函数同名"><a href="#函数同名" class="headerlink" title="函数同名"></a>函数同名</h4><p>提升函数（函数表达式声明的函数提升函数名–可能因为没有赋值而报错）到函数调用前，调用在后面的</p><h4 id="条件式函数"><a href="#条件式函数" class="headerlink" title="条件式函数"></a>条件式函数</h4><p>与函数表达式提升方式类似</p><p>//如果以后有需求：条件满足是一种函数声明，条件不满足是另外一种函数声明，就写如下代码。</p><p>   var num = 10;</p><p>   var test;</p><p>   if(num &gt; 0){</p><p>​     test = function () {</p><p>​       console.log(“哈哈”);</p><p>​     }</p><p>   }else {</p><p>​     test = function () {</p><p>​       console.log(“嘿嘿”);</p><p>​     }</p><p>   }</p><p>   test();</p><h4 id="函数中的形参声明和赋值的过程是在预解析之前的（不参与预解析）"><a href="#函数中的形参声明和赋值的过程是在预解析之前的（不参与预解析）" class="headerlink" title="函数中的形参声明和赋值的过程是在预解析之前的（不参与预解析）"></a>函数中的形参声明和赋值的过程是在预解析之前的（不参与预解析）</h4><p>  function test1(test2){</p><p>​    // var test2 = 10; 这里打开会报错，因为如果变量和函数同名，变量有值，会使用变量test2不是函数</p><p>​    function test2(){</p><p>​      console.log(“哈哈”);</p><p>​    }</p><p>​    test2();</p><p>  }</p><p>  test1(10);</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>//  var a;</p><p>//  if(“a” in window){</p><p>//    a = 10;</p><p>//  }</p><p>//  alert(a); // 10</p><p>  //———————</p><p> if(“a” in window){</p><p>   var a = 10;</p><p> }</p><p> alert(a); // 10</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>自己调用自己，一定要有结束的条件</p><p>.children找到所有的子代   .childNodes找到所有的子代节点</p><p> function getEles(ele){</p><p>​    var list = [];</p><p>​    var children = ele.children;</p><p>​    for(var i = 0 ; i &lt; children.length; i++){</p><p>​      var child = children[i];</p><p>​        list.push(child);</p><p>​        var temp = getEles(child);</p><p>​        list =  list.concat(temp);</p><p>​    }</p><p>​    return list;</p><p>  }</p><p>  var father = document.getElementById(“father”);</p><p>  var list1 = getEles(father);</p><p>  console.log(list1);</p><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h2><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p><p>语法：Object.defineProperty(obj, prop, descriptor)</p><p>  //参数1obj: 需要操作的对象</p><p>  //参数2prop: 需要定义的那个属性</p><p>  //参数3descriptor ： 这个属性需要的一些描述，他是一个对象。</p><p>​     writable :当且仅当该属性的 writable 为 true 时，该属性才能被赋值运算符改变。默认为 false。</p><p>​         configurable :当且仅当该属性的 configurable 为 true 时，属性也能从对应的对象上被删除。默认为             false。</p><p>​         enumerable : 当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。</p><p>​         value:  该属性对应的值。</p><p>​         get  set  不能和value以及writable 一起使用。</p><p>​             给属性赋值，相当于调用了set方法、取属性的值，相当于调用了get方法</p><p>​             get set 其实就是给这个对象的属性赋值或者取值的时候，做一个过滤的逻辑。</p><p>​             如果设置某个属性，只有get没有set，那么这个属性就是一个只读属性； 相反，如果某个属性只有set没有get，那么这个属性就是一个只写属性。</p><h2 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h2><p>定义在一个函数内部的函数，能够读取其他函数内部的变量</p><h3 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h3><p>第一种：</p><p> function test1(){</p><p>   var num = 10;</p><p>   function test2(){</p><p>​     return num;</p><p>   }</p><p>   return test2;</p><p> }</p><p> //调用test1函数，得到一个返回值f1，这个返回值f1其实就是那个test2函数。</p><p> var f1 = test1();</p><p> console.log(f1());</p><p>第二种：</p><p>此时test1保存的是这个自执行函数，执行之后的返回值。</p><p> var test1 = (function () {</p><p>   var num = 10;</p><p>   function test2(){</p><p>​     return num;</p><p>   }</p><p>   return test2;</p><p> }());</p><p> console.log(test1());           相当于只用调用一次。</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>使用闭包时候，外部函数只需要调用一次</p><p>//  var f1 = outer();</p><p>//  console.log(f1()); //11</p><p>//  console.log(f1()); //12</p><p>//  console.log(f1()); //13</p><p>如果f1是自调用函数的话，f1.s1（），f1.s1（），都是会针对同一个外部函数来运算的</p><p>//————————————————————————————–</p><p>//  console.log(outer()()); //11</p><p>//  console.log(outer()()); //11</p><p>//  console.log(outer()()); //11</p><p>特殊的：外部函数每次得到的是一种随机的，那么外部函数最好每次都调用</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>函数外部访问函数内部变量</p><p>延长生命周期</p><p>返回一个对象里面，包含需要执行的函数</p><p> function outer(){</p><p>   var num = 10;</p><p>   return {</p><p>​     getNum:function (){</p><p>​       return num;</p><p>​     },</p><p>​     setNum:function (value){</p><p>​       if(value &gt; 0){</p><p>​         num = value;</p><p>​       }</p><p>​     }</p><p>   };</p><p> }</p><p> //此时调用outer这个函数，返回一个对象，这个对象里面包含2个函数。</p><p> var o1 = outer();                //o1返回的是一个对象</p><p> o1.setNum(100);                //可以点出来</p><p> console.log(o1.getNum());                  </p><p>函数闭包解决循环注册i的问题</p><p>  for(var i = 0 ; i &lt; lis.length; i++){</p><p>​    //把这个递增的i每次保存起来</p><p>​    function outer(){</p><p>​      var j = i;</p><p>​      function inner(){</p><p>​        alert(j);</p><p>​      }</p><p>​      return inner;</p><p>​    }</p><p>​    lis[i].onclick = outer();            //这里需要一个函数，不需要调用</p><p>  }</p><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>js是单线程。先执行主要任务，再执行次要任务setTimeout，setInterval</p><p> for(var i = 0 ; i &lt; 10; i++){</p><p>   function outer(){</p><p>​     var j = i;</p><p>​     function inner(){</p><p>​       console.log(j);</p><p>​     }</p><p>​     return inner;</p><p>   }</p><p>   setTimeout(outer(),3000);            //两()是立即执行</p><p> }</p><h3 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h3><p>模块化，一个隔离的环境，减少全局变量的污染</p><p> (function (w) {</p><p>   function test1(){</p><p>​     console.log(“哈哈哈”);</p><p>   }</p><p>   function test2(){</p><p>​     console.log(“嘿嘿”);</p><p>   }</p><p>   w.test1 = test1;</p><p>   w.test2 = test2;                    </p><p> }(window));</p><p> window.test1();</p><p> window.test2();</p><h3 id="缓存处理斐波那契数列"><a href="#缓存处理斐波那契数列" class="headerlink" title="缓存处理斐波那契数列"></a>缓存处理斐波那契数列</h3><p>  var i = 0;</p><p>  var obj = {};</p><p>  function getFibo(n){</p><p>​    i++;</p><p>​    //先去缓存中看看，有没有这值</p><p>​    if(obj[n]){</p><p>​      return obj[n];</p><p>​    }else {</p><p>​      //缓存中没有，说明之前没有算过，就要计算。</p><p>​      if(n == 1 || n == 2){</p><p>​         obj[n] = 1;</p><p>​      }else {</p><p>​         obj[n] = getFibo(n-1) + getFibo(n-2);</p><p>​      }</p><p>​      return obj[n];</p><p>​    }</p><p>  }</p><p>console.log(getFibo(50)); //</p><p>  console.log(i); </p><h3 id="闭包方式处理斐波那契数列"><a href="#闭包方式处理斐波那契数列" class="headerlink" title="闭包方式处理斐波那契数列"></a>闭包方式处理斐波那契数列</h3><p>  function createFibo(){</p><p>​    var obj = {};</p><p>​    function getFibo(n){</p><p>​      if(obj[n]){</p><p>​        return obj[n];</p><p>​      }else {</p><p>​        if(n == 1 || n == 2){</p><p>​          obj[n] = 1;</p><p>​        }else {</p><p>​          obj[n] = getFibo(n-1) + getFibo(n-2);</p><p>​        }</p><p>​        return obj[n];</p><p>​      }</p><p>​    }</p><p>​    return getFibo;</p><p>  }</p><p>  var f1 = createFibo();</p><p>  console.log(f1(50));</p><h2 id="数组的高级方法"><a href="#数组的高级方法" class="headerlink" title="数组的高级方法"></a>数组的高级方法</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>语法：obj.forEach(function(value,index,arr){})</p><p> //参数1：value 就是正在处理的数组的元素</p><p> //参数2：index 就是正在处理的数组的元素的下标</p><p> //参数3：就是这个正在处理的数组。              没什么用的</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>数组的映射</p><p> var arr = [1,2,3,4,5];</p><p>   var arrNew = arr.map(function (value, index, arr) {</p><p>​          return value * 2;     //2,3,6,8,10</p><p>  });</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>var arr = [2, 3 ,10,15,99];</p><p>var arrNew = arr.filter(function (value,index,arr) {</p><p>​    return value &gt; 10;</p><p>  });</p><h2 id="函数的三种执行方式"><a href="#函数的三种执行方式" class="headerlink" title="函数的三种执行方式"></a>函数的三种执行方式</h2><p>a.作为函数来执行</p><p>​    this指代 的window</p><p>b.作为方法执行</p><p>​    this指代的就是就是这个方法对象</p><p>c.作为构造函数指向</p><p>​    如果new创建出来的对象，那么this指代这个对象</p><p>​    如果把构造函数当成普通函数来执行的话，那么this指代window</p><p><strong>//不管函数是怎么声明的，要看这个函数里面的this是谁，要看他是怎么调用的。</strong></p><p><strong>//谁调用你这个函数，你这个函数里面的this就是谁。</strong></p><h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h3 id="寄生模式"><a href="#寄生模式" class="headerlink" title="寄生模式"></a>寄生模式</h3><p>//寄生模式，把工厂模式的函数作为了 构造函数来调用，所以这个函数里面的this就是new关键字创建出来的那个对象。</p><p>function createPerson(name){</p><p>​    var obj = new Object();</p><p>​    obj.name = name;</p><p>​    obj.sayHi = function () {</p><p>​      console.log(“哈哈哈:”+this.name);</p><p>​    }</p><p>​    this.sayHi = function () {</p><p>​      console.log(“呵呵”);</p><p>​    }</p><p>​    console.log(this);</p><p>​    return obj;                        //因为这里返回的是一个复杂类型的的对象，所以。。。。</p><p>  }</p><p>  //寄生模式，把工厂模式的函数作为了 构造函数来调用，所以这个函数里面的this就是new关键字创建出来的那个对象。</p><p>  var p1 = new createPerson(“某婷”);</p><p>  p1.sayHi();</p><h2 id="函数上下文调用模式call-apply"><a href="#函数上下文调用模式call-apply" class="headerlink" title="函数上下文调用模式call(),apply()"></a>函数上下文调用模式call(),apply()</h2><p>函数调用，方法调用，构造函数调用中的this无法改变指向</p><p>这两个方法存在于Function.prototype中，js中任意对象都有</p><p>在传入一个基本数据类型this指向对应的包装类型Number,,,,,,</p><p>传入undefined,null,window或者为空的时候this指向window</p><p>谁调用的这两个方法，谁里面的this就改了</p><p>一般将有某个方法给某个对象，某个对象作为参数一</p><h3 id="call"><a href="#call" class="headerlink" title=".call()"></a>.call()</h3><p>语法：函数名.call(this需要指向的对象,arg1,arg2….);</p><h3 id="apply"><a href="#apply" class="headerlink" title=".apply()"></a>.apply()</h3><p>语法：函数名.apply(this需要指向的对象,数组或者一个伪数组);</p><h3 id="bind"><a href="#bind" class="headerlink" title=".bind()"></a>.bind()</h3><p> function test1(){</p><p>​    console.log(this);            //test1调用了，所以这里面的this改为obj对象</p><p>  }</p><p>  var obj = {</p><p>​    name:”张三”</p><p>  };</p><p>  function test3(){</p><p>​    test1.call(obj);</p><p>​    console.log(this);            //普通函数调用this指代window</p><p>  }</p><p>  test3();</p><h3 id="伪数组转为真数组"><a href="#伪数组转为真数组" class="headerlink" title="伪数组转为真数组"></a>伪数组转为真数组</h3><p>伪数组：</p><p>  var disArr = {</p><p>​    0:”林黑群”,</p><p>​    1:”周骚林”,</p><p>​    2:”胡1号”,</p><p>​    3:”凤姐”,</p><p>​    4:”四妹”,</p><p>​    length:5</p><p>  };                                //是个对象，但是长得要像数组，index，length要有、</p><p>1.var arr = [];</p><p>  for(var i = 0 ; i &lt; disArr.length; i++){</p><p>​    arr[i] = disArr[i];</p><p>  }</p><p>  console.log(arr)</p><p>2.disArr = Array.prototype.slice.call(disArr);</p><p>  console.log(disArr);</p><p>3.var arr = [];</p><p>  arr.push.apply(arr,disArr);</p><p>  console.log(arr);</p><p>4.var arr = [];</p><p>  arr = arr.concat.apply(arr,disArr);</p><p>  console.log(arr);</p><h3 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max"></a>Math.max</h3><p>  var arr = [10,20,5,40,100];</p><p>  var max = Math.max.apply(Math,arr);</p><p>  console.log(max);</p><h3 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort"></a>Array.prototype.sort</h3><p> Array.prototype.sort.call(disArr, function (a,b) {</p><p>​    return b-a;</p><p>  });</p><p>  console.log(disArr);</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;javascript高级&quot;&gt;&lt;a href=&quot;#javascript高级&quot; class=&quot;headerlink&quot; title=&quot;javascript高级&quot;&gt;&lt;/a&gt;javascript高级&lt;/h1&gt;
    
    </summary>
    
      <category term="前端" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E5%89%8D%E7%AB%AF/javascript/"/>
    
    
      <category term="javascript" scheme="https://github.com/ztopia/ztopia.github.io.git/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>hello</title>
    <link href="https://github.com/ztopia/ztopia.github.io.git/2016/05/07/hello-world/"/>
    <id>https://github.com/ztopia/ztopia.github.io.git/2016/05/07/hello-world/</id>
    <published>2016-05-07T14:37:23.000Z</published>
    <updated>2017-11-26T01:23:08.480Z</updated>
    
    <content type="html"><![CDATA[<p>摘要:<br><a id="more"></a><br>正文:this is my first blog!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要:&lt;br&gt;
    
    </summary>
    
      <category term="日志" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E6%97%A5%E5%BF%97/"/>
    
      <category term="经验总结" scheme="https://github.com/ztopia/ztopia.github.io.git/categories/%E6%97%A5%E5%BF%97/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="hello" scheme="https://github.com/ztopia/ztopia.github.io.git/tags/hello/"/>
    
  </entry>
  
  <entry>
    <title>My New Post</title>
    <link href="https://github.com/ztopia/ztopia.github.io.git/2016/05/05/My-New-Post/"/>
    <id>https://github.com/ztopia/ztopia.github.io.git/2016/05/05/My-New-Post/</id>
    <published>2016-05-05T01:46:09.000Z</published>
    <updated>2017-11-26T01:23:09.936Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
